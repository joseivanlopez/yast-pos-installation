/**
 * Package:     POS Installation
 * Summary:     Installation of SLEPOS packages
 * Authors:	Lukas Ocilka <locilka@suse.cz>
 *		Jiri Suchomel <jsuchome@suse.cz>
 *
 * This client should be called during 2nd stage of installation or update
 * of SLES11 together with SLEPOS
 */

{
    textdomain "slepos-installation";

    import "GetInstArgs";
    import "Label";
    import "Mode";
    import "PackageCallbacks";
    import "PackagesUI";
    import "Popup";
    import "POSInstallation";
    import "Report";
    import "Stage";
    import "Wizard";

    y2milestone ("SLEPOS installation client (%1, %2)", Mode::mode (), Stage::stage ());

    if (Mode::normal())
	Wizard::CreateDialog();

    list <map <string, string> > list_of_patterns = [
	$[
	    // TRANSLATORS: A name of pattern, used as CheckBox label
	    "label"	: _("Admin Server"),
	    "name"	: "SLEPOS_Server_Admin",
	    "icon"	: "/usr/share/icons/hicolor/32x32/apps/yast-host.png",
	],
	$[
	    // TRANSLATORS: A name of pattern, used as CheckBox label
	    "label"	: _("Branch Server"),
	    "name"	: "SLEPOS_Server_Branch",
	    "icon"	: "/usr/share/icons/hicolor/32x32/apps/yast-network.png",
	],
	$[
	    // TRANSLATORS: A name of pattern, used as CheckBox label
	    "label"	: _("Image Server"),
	    "name"	: "SLEPOS_Image_Server",
	    "icon"	: "/usr/share/icons/hicolor/32x32/apps/yast-sw_source.png",
	],
    ];

    // initialize source and target (if already done, nothing happens)
    if (!GetInstArgs::going_back ())
    {
	Pkg::SourceStartManager (true);
	Pkg::TargetInit ("/", false);
    }


    map map_of_patterns	= listmap (map pattern, list_of_patterns, {
	return $[
	    pattern["name"]:"" : pattern
	];
    });

    // check which configuration is detected by slepos scripts and
    // mark appropriate patterns for migration
    void InitSelected () {

	foreach (map <string, string> one_pattern, list_of_patterns, {
	    string name	= one_pattern["name"]:"";
	    if (POSInstallation::detected[name]:false)
	    {
		y2milestone ("checking pattern %1 for migration...", name);
		UI::ChangeWidget (`id ("migrate_" + name), `Value, true);
		UI::ChangeWidget (`id ("install_" + name), `Value, true);
		// do not let user unselect migrated pattern
		UI::ChangeWidget (`id ("install_" + name), `Enabled, false);
	    }
	});
    }

    boolean manual_package_selection () {

	symbol ret = PackagesUI::RunPatternSelector ();

	// user didn't accept the pattern selector
	if (ret != `accept) {
	    return false;
	} else {
	    Pkg::PkgCommit (0);
	    return true;
	}
    }

    /**
     * Check which patterns are selected for installation and migration,
     * install required ones and save info about migration
     */
    boolean HandleSelected () {

	list<string> to_install	= [];

	map for_migration     = $[];

	foreach (map <string, string> one_pattern, list_of_patterns, {
	    string name = one_pattern["name"]:"";
	    if (UI::QueryWidget (`id ("install_" + name), `Value) == true)
	    {
		y2internal ("pattern %1 selected for installation", name);
		to_install	= add (to_install, name);
	    }
	    if (UI::WidgetExists (`id ("migrate_" + name)) &&
		UI::QueryWidget (`id ("migrate_" + name), `Value) == true)
	    {
		y2internal ("pattern %1 selected for migration", name);
		for_migration[name]	= true;
	    }
	});
	/* filter out already installed (FIXME???)
	to_install	= filter (string pattern, to_install, {
	    list <map <string,any> > current_pattern_state = Pkg::ResolvableProperties (pattern, `pattern, "");
	});
	*/

	list<string> failed_patterns	= [];
	foreach (string pattern, to_install, {
	    if (Pkg::ResolvableInstall (pattern, `pattern) == false) {
		y2error ("Can't select pattern %1", pattern);
		failed_patterns = add (failed_patterns, pattern);
	    }
	});
	if (failed_patterns != [])
	{
	    string labels = mergestring (
		maplist (string pat, failed_patterns, ``(map_of_patterns[pat,"label"]:pat)),
		"\n"
	    );
	    // TRANSLATORS: Error message, %1 is replaced with the name of the pattern
	    Report::Error (sformat(_("Unable to select patterns:\n%1\nStarting manual selection."),
		labels));
	    return manual_package_selection ();
	}
	if (to_install != [])
	{
	    if (Pkg::PkgSolve (false) == true) {
		Pkg::PkgCommit (0);
	    }
	    else {
		// TRANSLATORS: Error message
		Report::Error (_("An error occured in pattern selection\nStarting manual selection."));
		return manual_package_selection ();
	    }
	}

	// update the migrate info for the next dialog
	POSInstallation::for_migration	= for_migration;

	return true;
    }

    term CreateCheckBoxTerm (string pattern_name, string pattern_label, string pattern_icon) {
	return `HBox (
	    `HSpacing (2),
	    pattern_icon == "" ? `Empty() : `Image (pattern_icon, ""),
	    `HSpacing (2),
	    `Left (`CheckBox (`id (pattern_name), `opt (`notify), pattern_label))
	);
    }

    term install_patterns = `VBox ();
    term migrate_patterns	= `VBox ();

    foreach (map <string, string> one_pattern, list_of_patterns, {

	string name	= one_pattern["name"]:"";

	install_patterns = add (install_patterns,
	    CreateCheckBoxTerm (
		"install_" + name,
		one_pattern["label"]:"",
		one_pattern["icon"]:""
	    )
	);
	install_patterns = add (install_patterns, `VSpacing (0.7));

	if (POSInstallation::detected[name]:false)
	{
	    migrate_patterns = add (migrate_patterns,
		CreateCheckBoxTerm (
		    "migrate_" + name,
		    one_pattern["label"]:"",
		    one_pattern["icon"]:""
		)
	    );
	    migrate_patterns = add (migrate_patterns, `VSpacing (0.7));
	}
    });


    if (size (migrate_patterns) > 0)
    {
	migrate_patterns	= `HBox (
	    `HSpacing (3),
	    // frame label
	    `Frame (_("Data Migration"), `VBox (
		`VSpacing (0.7),
		migrate_patterns)
	    ),
	    `HSpacing (3)
	);
    }

    term cont	= `VBox (
	migrate_patterns,
	`VSpacing (),
	`HBox (
	    `HSpacing (3),
	    // frame label
	    `Frame (_("Pattern Installation"), `VBox (
		`VSpacing (0.7),
		install_patterns)
	    ),
	    `HSpacing (3)
	)
    );

    Wizard::SetContentsButtons (
	// TRANSLATORS: Dialog caption
	_("Server Pattern Selection"),
	cont,

	// help text
	_("<p>Choose the pattern which you want to install. You may disable the migration
of the relevant deployment (AS, BS or IS).</p>") +

	// help text, cont.
	_("<p>The installation will start upon pressing <b>Next</b>.</p>"),

	Label::BackButton(),
	Label::NextButton()
    );

    Wizard::SetTitleIcon ("yast-software");

    InitSelected ();

    any ret = nil;

    symbol dialog_ret = `next;

    while (true) {
	ret = UI::UserInput();

	if (is (ret, string))
	{
	    string sret	= tostring (ret);
	    if (substring (sret, 0, 8) == "migrate_")
	    {
		string rest	= substring (sret, 8);
		// migrated pattern must be installed
		UI::ChangeWidget (`id ("install_" + rest), `Value, true);
		UI::ChangeWidget (`id ("install_" + rest), `Enabled,
		    UI::QueryWidget (`id (ret), `Value) != true);
	    }
	}
	else if (ret == `next)
	{
	    dialog_ret = `next;
	    if (HandleSelected ()) {
		break;
	    } else {
		continue;
	    }
	} else if (ret == `back) {
	    dialog_ret = `back;
	    break;
	} else if (ret == `abort || ret == `cancel) {
	    if (Popup::ConfirmAbort (`incomplete)) {
		dialog_ret = `abort;
		break;
	    } else {
		continue;
	    }
	} else {
	    y2error ("Unhandled ret: %1", ret);
	}
    }

    if (Mode::normal())
	Wizard::CloseDialog();

    return dialog_ret;
}
