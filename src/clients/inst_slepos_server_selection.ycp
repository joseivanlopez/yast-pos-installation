/**
 */

{
    textdomain "slepos-installation";

    import "Wizard";
    import "Label";
    import "Popup";
    import "Installation";
    import "Mode";
    import "Report";
    import "Stage";
    import "PackageCallbacks";
    import "Directory";
    import "String";
    import "FileUtils";

    if (Mode::normal())
	Wizard::CreateDialog();

    list <map <string, string> > list_of_patterns = [
	$[
	    // TRANSLATORS: A name of pattern, used as RadioButton label
	    "label"	: _("Admin Server Installation"),
	    "name"	: "SLEPOS_Server_Admin",
	    "icon"	: "/usr/share/icons/hicolor/32x32/apps/yast-host.png",
	],
	$[
	    // TRANSLATORS: A name of pattern, used as RadioButton label
	    "label"	: _("Branch Server Installation"),
	    "name"	: "SLEPOS_Server_Branch",
	    "icon"	: "/usr/share/icons/hicolor/32x32/apps/yast-network.png",
	],
	$[
	    // TRANSLATORS: A name of pattern, used as RadioButton label
	    "label"	: _("Image Server Installation"),
	    "name"	: "SLEPOS_Image_Server",
	    "icon"	: "/usr/share/icons/hicolor/32x32/apps/yast-source.png",
	],
    ];

    /**
     * Describes mapping of old selections to new patterns for the upgrade case.
     *
     * @struct $[
     *   "selection_name" : [ "list", "of", "new", "patterns", ... ],
     *   ...
     * ]
     */
    map <string, list <string> > selections_to_patterns = $[
	"SLRS-Server"		: [ "SLEPOS_Server_Admin", "SLEPOS_Server_Branch" ],
	"SLRS_Image"		: [ "SLEPOS_Image" ],
	"SLRS_Image_Server"	: [ "SLEPOS_Image_Server" ],
    ];

    list <string> all_patterns_in_selection = [];

    void InitTargetNow () {
	Pkg::SourceStartManager (true);
	Pkg::TargetInit (Installation::destdir, false);
    }

    string GetPatternLabel (string pattern_name) {
	string pattern_label = pattern_name;

	foreach (map <string, string> one_pattern, list_of_patterns, {
	    if (one_pattern["name"]:nil == pattern_name) {
		pattern_label = one_pattern["label"]:pattern_name;
		break;
	    }
	});

	return pattern_label;
    }

    string already_proposed = Directory::tmpdir + "/SLEPOS_upgrade_already_proposed";

    void ProposeUpgrade () {
        if (FileUtils::Exists (already_proposed)) {
            y2milestone ("Already proposed");
	    return;
        } else {
            y2milestone ("Proposing upgrade");
            SCR::Execute (.target.bash, sformat ("touch '%1'", String::Quote (already_proposed)));
        }

        string selections_stored_in = Installation::destdir + "/var/adm/YaST/SelDB/";

        list <string> selections_in_use = [];
        if (FileUtils::Exists (selections_stored_in)) {
            selections_in_use = (list <string>) SCR::Read (.target.dir, selections_stored_in);
            y2milestone ("Selections currently in use: %1", selections_in_use);
        } else {
            y2warning ("Directory %1 doesn't exist", selections_stored_in);
        }

	boolean need_to_solve = false;;

	// check all selections in use
        foreach (string one_selection, selections_in_use, {
            if (! regexpmatch (one_selection, "^.*\.sel$")) {
                y2warning ("Not a selection: %1", one_selection);
                return;
            }

            one_selection = regexpsub (one_selection, "^(.*)\.sel$", "\\1");

	    // there's no need to handle that selection
	    if (! haskey (selections_to_patterns, one_selection)) return;

	    list <string> patterns_affected = selections_to_patterns[one_selection]:[];

	    // internal error, wrong definition
	    if (patterns_affected == [] || patterns_affected == nil) {
		y2error ("Wrong definition of patterns affected! %1", patterns_affected);
		return;
	    }

	    foreach (string one_pattern_name, patterns_affected, {
		if (one_pattern_name == nil || one_pattern_name == "") {
		    y2error ("Wrong pattern for %1 -> %2", one_selection, one_pattern_name);
		    return;
		}

		list <map <string,any> > current_pattern_state = Pkg::ResolvableProperties (one_pattern_name, `pattern, "");

		// pattern is known
		if (size (current_pattern_state) > 0) {
		    y2milestone ("Preselecting pattern: %1", one_pattern_name);
		    Pkg::ResolvableInstall (one_pattern_name, `pattern);
		// no such pattern
		} else {
		    y2error ("No such pattern available %1", one_pattern_name);
		}
	    });
        });

	if (need_to_solve) {
	    y2milestone ("Some patterns were selected...");
	    Pkg::PkgSolve (false);
	}
    }

    void InitSelectedRadioButton () {
	// check all patterns visible in the dialog
	// if more then one (of them) pattern is selected, select "detailed"
	// otherwise preselect that only one pattern in dialog
	list <string> already_selected_patterns = [];
	string one_pattern_name = "";

	foreach (map <string, string> one_pattern, list_of_patterns, {
	    one_pattern_name = one_pattern["name"]:"";

	    if (one_pattern_name == "" || one_pattern_name == nil) {
		y2error ("Wrong pattern definition: %1", one_pattern);
		return;
	    }

	    list <map <string,any> > current_pattern_state = Pkg::ResolvableProperties (one_pattern["name"]:"", `pattern, "");
	    current_pattern_state = filter (map <string,any> one_pattern, current_pattern_state, {
		// `selected (for installation) or already `installed
		return (one_pattern["status"]:nil == `installed || one_pattern["status"]:nil == `selected);
	    });

	    if (size (current_pattern_state) > 1) {
		y2warning ("More patterns matching: %1", current_pattern_state);
	    } else if (size (current_pattern_state) == 0) {
		y2warning ("No pattern matching %1", one_pattern["name"]:"");
		return;
	    }

	    foreach (map <string,any> one_pattern, current_pattern_state, {
		string one_pattern_name = one_pattern["name"]:"";

		if (one_pattern_name != "" && one_pattern_name != nil) {
		    already_selected_patterns = add (already_selected_patterns, one_pattern_name);
		} else {
		    y2error ("No 'name' defined: %1", one_pattern);
		}
	    });
	});

	if (size (already_selected_patterns) > 1) {
	    y2milestone ("More than one pattern selected: %1, preselecting 'detailed'", already_selected_patterns);
	    UI::ChangeWidget (`id (`selected_pattern), `CurrentButton, "detailed");
	} else if (size (already_selected_patterns) == 1) {
	    y2milestone ("Only one pattern selected: %1", already_selected_patterns);
	    UI::ChangeWidget (`id (`selected_pattern), `CurrentButton, sformat("pattern: %1", already_selected_patterns[0]:""));
	} else {
	    y2milestone ("There are no pre-selected POS patterns");
	}
    }

    boolean HandleSelectedRadioButton () {
	string current_button = (string) UI::QueryWidget (`id (`selected_pattern), `CurrentButton);

	if (current_button == "detailed") {
	    any ret = WFM::call ("inst_packages", [`patterns]);

	    // user didn't accept the pattern selector
	    if (ret != `accept) {
		return false;
	    } else {
		return true;
	    }
	} else if (regexpmatch (current_button, "^pattern: .*$")) {
	    foreach (string pattern_neutral, all_patterns_in_selection, {
		list <map <string,any> > current_pattern_state = Pkg::ResolvableProperties (pattern_neutral, `pattern, "");
		if (size (current_pattern_state) == 0) {
		    y2error ("No such pattern: %1", pattern_neutral);
		    return;
		}
		Pkg::ResolvableNeutral (pattern_neutral, `pattern, (Stage::initial() ? true:false));
	    });

	    string pattern_to_select = regexpsub (current_button, "^pattern: (.*)$", "\\1");

	    if (Pkg::ResolvableInstall (pattern_to_select, `pattern) == true) {
		Pkg::PkgSolve (false);
		return true;
	    } else {
		y2error ("Can't select pattern %1", pattern_to_select);
		// TRANSLATORS: Error message, %1 is replaced with the name of the pattern
		Report::Error (sformat(_("Unable to select pattern '%1'"), GetPatternLabel (pattern_to_select)));
		return false;
	    }
	} else {
	    y2error ("Unknown current button: %1", current_button);
	    return false;
	}
    }

    term CreateRadioButtonTerm (string pattern_name, string pattern_label, string pattern_icon) {
	return `HBox (
		`HWeight (
		    1,
		    `Right (pattern_icon == "" ? `Empty() : `Image (pattern_icon, ""))
		),
		`HSpacing (2),
		`HWeight (
		    2,
		    `Left (`RadioButton (
			`id (pattern_name),
			pattern_label
		    ))
		)
	    );
    }

    term term_patterns = `VBox ();

    all_patterns_in_selection = [];

    foreach (map <string, string> one_pattern, list_of_patterns, {
	all_patterns_in_selection = add (all_patterns_in_selection, one_pattern["name"]:"");

	term_patterns = add (
	    term_patterns,
	    CreateRadioButtonTerm (
		sformat ("pattern: %1", one_pattern["name"]:""),
		one_pattern["label"]:"",
		one_pattern["icon"]:""
	    )
	);
	term_patterns = add (term_patterns, `VSpacing (0.7));
    });

    term_patterns = add (term_patterns, `VSpacing (1));
    term_patterns = add (
	term_patterns,
	CreateRadioButtonTerm (
	    "detailed",
	    // TRANSLATORS: Radio button
	    _("Detailed Selection"),
	    ""
	)
    );

    Wizard::SetContentsButtons (
	// TRANSLATORS: Dialog caption
	_("Server Pattern Selection"),
	`RadioButtonGroup (
	    `id (`selected_pattern),
	    `opt (`notify),
	    term_patterns
	),
	// TRANSLATORS: Dialog help
	_("<p>Please choose what type of server you would like to install and 
	press <b>Next</b>.</p><br>
	In case you would like to make a detailed choice or install more services
	on one server please choose <b>Detailed Selection</b>.<br>
	<p>The installation will automatically start upon pressing <b>Next</b>.<br>
 	When the installation is complete the <b>Migration Assistant</b> window will 
	open and guide you through the migration process.</p>"),
	Label::BackButton(),
	Label::NextButton()
    );

    Wizard::SetTitleIcon ("yast-software");
    InitTargetNow();

    if (Mode::update() && Stage::initial()) {
	ProposeUpgrade();
    } else {
	y2milestone ("Not an initial update mode");
    }

    InitSelectedRadioButton();

    any ret = nil;

    symbol dialog_ret = `next;

    while (true) {
	ret = UI::UserInput();

	if (ret == `next) {
	    dialog_ret = `next;
	    if (HandleSelectedRadioButton()) {
		break;
	    } else {
		continue;
	    }
	} else if (ret == `back) {
	    dialog_ret = `back;
	    break;
	} else if (ret == `abort || ret == `cancel) {
	    if (Popup::ConfirmAbort (`incomplete)) {
		dialog_ret = `abort;
		break;
	    } else {
		continue;
	    }
	} else {
	    y2error ("Unhandled ret: %1", ret);
	}
    }

    if (Mode::normal())
	Wizard::CloseDialog();

    return dialog_ret;
}
